#!/usr/bin/env python
#
# bbbm - A background manager for Blackbox
# Copyright (C) 2004 Rob Spoor
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU Library General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public
# License along with this library; if not, write to the
# Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.
#

import sys, os
from string import split, strip, lstrip
from os.path import exists, expanduser, splitext, dirname
from getopt import getopt, GetoptError
from random import choice
from ConfigParser import ConfigParser
import gtk

version = "0.1";
extensions = [".jpg", ".jpeg", ".gif", ".ppm", ".pgm"]
homedir = expanduser("~/.bbbm")
config = homedir + os.sep + "bbbm.cfg"
thumbsdir = homedir + os.sep + "thumbs"

set_command, view_command, thumb_size, thumb_cols = None, None, None, 0

def read_options():
    global config, set_command, view_command, thumb_size, thumb_cols
    try:
        f = open(config, "r")
        lines = f.readlines()
        f.close()
    except IOError:
        sys.stderr.write("Error: could not read '" + config + "'\n")
        sys.exit(1)
    for i in range(len(lines)):
        line = lstrip(lines[i][:-1])
        if not line or line[0] == "#":
            continue
        try:
            option, value = split(line, " = ", 1)
        except ValueError:
            sys.stderr.write("Error on line " + (i + 1) + ": " + line + "\n")
            sys.exit(1)
        if option == "set_command":
            set_command = value
        if option == "view_command":
            view_command = value
        if option == "thumb_size":
            thumb_size = value
        if option == "thumb_cols":
            try:
                thumb_cols = int(value)
            except ValueError:
                sys.stderr.write("Illegal value of 'thumb_cols': " + value +\
                                 "\n")
                sys.exit(1)
    if not set_command:
        sys.stderr.write("Error: option 'set_command' missing\n")
        sys.exit(1)
    if not view_command:
        sys.stderr.write("Error: option 'view_command' missing\n")
        sys.exit(1)
    if not thumb_size:
        sys.stderr.write("Error: option 'thumb_size' missing\n")
        sys.exit(1)
    if not thumb_cols:
        sys.stderr.write("Error: option 'thumb_cols' missing or 0\n")
        sys.exit(1)
    if thumb_cols > 10:
        thumb_cols = 10

def write_options():
    global config, set_command, view_command, thumb_size, thumb_cols
    try:
        f = open(config, "w")
    except IOError:
        sys.stderr.write("Error: could not write to '" + config + "'\n")
        return
    # don't quit!
    f.write("# Warning: editing this file is not recommended.\n")
    f.write("# This file will be overwritten when bbbm closes.\n\n")
    f.write("set_command = " + set_command + "\n")
    f.write("view_command = " + view_command + "\n")
    f.write("thumb_size = " + thumb_size + "\n")
    f.write("thumb_cols = " + str(thumb_cols) + "\n")
    f.close()

class Image(gtk.EventBox):
    def __init__(self, filename, description, thumb):
        gtk.EventBox.__init__(self)
        image = gtk.Image()
        image.set_from_file(thumb)
        image.show()
        self.add(image)
        self.filename = filename
        self.description = description

class BBBM:
    def __init__(self, files):
        self.padding = 5
        self.images = []
        self.filename = None
        self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.window.set_default_size(640, 480)
        self.window.set_title("bbbm " + version)
        self.window.set_position(gtk.WIN_POS_CENTER)
        self.window.connect("delete_event", self.exit)

        vbox = gtk.VBox(gtk.FALSE, 0)
        vbox.set_border_width(0)
        self.window.add(vbox)
        vbox.show()

        menu_bar = self.create_bar(self.window)
        vbox.pack_start(menu_bar, gtk.FALSE, gtk.TRUE, 0)
        self.status_bar = gtk.Statusbar()
        self.context_id = self.status_bar.get_context_id("Statusbar")
        vbox.pack_end(self.status_bar, gtk.FALSE, gtk.FALSE, 0)

        self.scroll = gtk.ScrolledWindow()
        self.table = gtk.Table(1, 1, gtk.TRUE)
        self.table.show()
        self.scroll.add_with_viewport(self.table)
        vbox.pack_start(self.scroll, gtk.TRUE, gtk.TRUE, 0)
        self.scroll.show()

        menu_bar.show()
        self.status_bar.show()
        self.window.show()
        if files:
            if exists(files[0]):
                self.open_collection(files[0])
            else:
                sys.stderr.write("Error: could not find '" + files[0] + "'\n")

    def create_bar(self, window):
        menu_items = (
            ("/_File", None, None, 0, "<Branch>"),
            ("/File/_Open...", "<ctrl>O", self.open, 0, None),
            ("/File/_Save", "<ctrl>S", self.save, 0, None),
            ("/File/Save _As...", "<ctrl><shift>S", self.save_as, 0, None),
            ("/File/_Close", "<ctrl>C", self.close, 0, None),
            ("/File/sep", None, None, 0, "<Separator>"),
            ("/File/E_xit", "<alt>F4", self.exit, 0, None),
            ("/_Edit", None, None, 0, "<Branch>"),
            ("/Edit/_Add Image...", "<ctrl>A", self.add_image, 0, None),
            ("/Edit/Add _Collection...", "<ctrl><shift>A",\
             self.add_collection, 0, None),
            ("/_Tools", None, None, 0, "<Branch>"),
            ("/Tools/Create _List...", "<ctrl>L", self.create_list, 0, None),
            ("/Tools/Create _Menu...", "<ctrl>M", self.create_menu, 0, None),
            ("/Tools/_Random Background", "<ctrl>R", self.random_background,\
             0, None),
            ("/Tools/sep", None, None, 0, "<Separator>"),
            ("/Tools/_Options...", "<alt>P", self.options, 0, None),
            ("/_Help", None, None, 0, "<Branch>"),
            ("/Help/_About", None, self.about, 0, None)
        )
        accel_group = gtk.AccelGroup()
        item_factory = gtk.ItemFactory(gtk.MenuBar, "<main>", accel_group)
        item_factory.create_items(menu_items)
        window.add_accel_group(accel_group)
        return item_factory.get_widget("<main>")

    def open(self, widget, data):
        # sometimes the statusbar does not get cleared; do it manually
        self.clear_status(None, None)
        chooser = gtk.FileSelection("Select a collection")
        chooser.set_transient_for(self.window)
        chooser.set_select_multiple(gtk.FALSE)
        if chooser.run() == gtk.RESPONSE_OK:
            self.open_collection(chooser.get_filename())
        chooser.destroy()

    def open_collection(self, file):
        # opening a new collection is adding a new collection with closing the
        # previous opened collection and setting the filename first
        self.close(None, None)
        self.filename = file
        self.add_col(file)

    def save(self, widget, data):
        if self.filename:
            f = open(self.filename, "w")
            for i in self.images:
                f.write(i.filename + "\n" + i.description + "\n")
            f.close()
        else:
            self.save_as(None, None)

    def save_as(self, widget, data):
        # sometimes the statusbar does not get cleared; do it manually
        self.clear_status(None, None)
        chooser = gtk.FileSelection("Save as")
        chooser.set_transient_for(self.window)
        chooser.set_select_multiple(gtk.FALSE)
        if chooser.run() == gtk.RESPONSE_OK:
            self.filename = chooser.get_filename()
            self.save(widget, data)
        chooser.destroy()

    def close(self, widget, data):
        for i in self.table.get_children():
            self.table.remove(i)
        self.images = []
        self.filename = None
        self.status_bar.pop(self.context_id)

    def exit(self, widget, data):
        global config, thumbsdir
        write_options()
        # remove thumbs
        os.system("rm -rf " + thumbsdir + os.sep + "*")
        gtk.mainquit()

    def add_image(self, widget, data):
        global extensions
        # sometimes the statusbar does not get cleared; do it manually
        self.clear_status(None, None)
        chooser = gtk.FileSelection("Select an image")
        chooser.set_transient_for(self.window)
        chooser.set_select_multiple(gtk.TRUE)
        chooser.hide_fileop_buttons()
        if chooser.run() == gtk.RESPONSE_OK:
            for i in chooser.get_selections():
                if splitext(i)[1] in extensions:
                    self.add_img(i)
        chooser.destroy()

    def add_img(self, filename, description=None):
        global thumbsdir, thumb_size, thumb_cols
        if not description:
            description = filename
        if not exists(thumbsdir):
            os.mkdir(thumbsdir)
        thumb = thumbsdir + os.sep + filename
        if not exists(dirname(thumb)):
            os.makedirs(dirname(thumb))
        cmd = ["convert", "-size", thumb_size, "-resize", thumb_size,\
               filename, thumb]
        os.spawnvp(os.P_WAIT, "convert", cmd)
        image = Image(filename, description, thumb)
        image.connect_object("button-press-event", self.set_img, image)
        image.connect_object("button-release-event", self.popup, image)
        image.connect_object("enter-notify-event", self.set_status, image)
        image.connect_object("leave-notify-event", self.clear_status, image)
        image.show()
        img_num = len(self.images)
        c = img_num % thumb_cols
        r = img_num / thumb_cols
        self.images.append(image)
        self.table.attach(image, c, c + 1, r, r + 1, 0, 0,\
                          self.padding, self.padding)

    def set_status(self, image, event):
        self.status_bar.push(self.context_id, image.description)

    def clear_status(self, image, event):
        self.status_bar.pop(self.context_id)

    def add_collection(self, widget, data):
        # sometimes the statusbar does not get cleared; do it manually
        self.clear_status(None, None)
        chooser = gtk.FileSelection("Select a collection")
        chooser.set_transient_for(self.window)
        chooser.set_select_multiple(gtk.TRUE)
        if chooser.run() == gtk.RESPONSE_OK:
            for i in chooser.get_selections():
                self.add_col(i)
        chooser.destroy()

    def add_col(self, file):
        global extensions
        self.filename = file
        f = open(self.filename, "r")
        lines = f.readlines()
        f.close()
        while lines:
            try:
                file, desc, lines = strip(lines[0]), strip(lines[1]), lines[2:]
            except IndexError:
                file, lines = strip(lines[0]), lines[1:]
                desc = file
            if exists(file) and splitext(file)[1] in extensions:
                self.add_img(file, desc)

    def options(self, widget, data):
        global set_command, view_command, thumb_size, thumb_cols
        # sometimes the statusbar does not get cleared; do it manually
        self.clear_status(None, None)
        dialog = gtk.Dialog("Options", self.window, 0,\
                            (gtk.STOCK_OK, gtk.RESPONSE_OK,
                             gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL))
        frame = gtk.Frame("Commands")
        table = gtk.Table(2, 2, gtk.TRUE)
        label = gtk.Label("Set command:")
        label.show()
        table.attach(label, 0, 1, 0, 1)
        set_entry = gtk.Entry()
        set_entry.set_text(set_command)
        set_entry.show()
        table.attach(set_entry, 1, 2, 0, 1)
        label = gtk.Label("View command:")
        label.show()
        table.attach(label, 0, 1, 1, 2)
        view_entry = gtk.Entry()
        view_entry.set_text(view_command)
        view_entry.show()
        table.attach(view_entry, 1, 2, 1, 2)
        table.show()
        frame.add(table)
        frame.show()
        dialog.vbox.pack_start(frame, gtk.TRUE, gtk.TRUE, 0)

        frame = gtk.Frame("Thumbnails")
        table = gtk.Table(2, 2, gtk.TRUE)
        label = gtk.Label("Thumbnail size:")
        label.show()
        table.attach(label, 0, 1, 0, 1)
        size_entry = gtk.Entry()
        size_entry.set_text(thumb_size)
        size_entry.show()
        table.attach(size_entry, 1, 2, 0, 1)
        label = gtk.Label("Thumbnail columns:")
        label.show()
        table.attach(label, 0, 1, 1, 2)
        adj = gtk.Adjustment(thumb_cols, 1, 10, 1, 1, 1)
        cols_entry = gtk.SpinButton(adj, 1, 0)
        cols_entry.show()
        table.attach(cols_entry, 1, 2, 1, 2)
        table.show()
        frame.add(table)
        frame.show()
        dialog.vbox.pack_start(frame, gtk.TRUE, gtk.TRUE, 0)

        if dialog.run() == gtk.RESPONSE_OK:
            set_command = set_entry.get_text()
            view_command = view_entry.get_text()
            if thumb_size != size_entry.get_text():
                thumb_size = size_entry.get_text()
                # TODO: resize old thumbs
            if thumb_cols != cols_entry.get_value_as_int():
                thumb_cols = cols_entry.get_value_as_int()
                self.layout(0)
        dialog.destroy()

    def layout(self, i):
        global thumb_cols
        num_imgs = len(self.images)
        for i in range(i, num_imgs):
            self.table.remove(self.images[i])
            c = i % thumb_cols
            r = i / thumb_cols
            self.table.attach(self.images[i], c, c + 1, r, r + 1, 0, 0,\
                              self.padding, self.padding)
        cols = min(thumb_cols, num_imgs)
        rows = num_imgs / thumb_cols + (num_imgs % thumb_cols != 0)
        self.table.resize(rows, cols)

    def create_menu(self, widget, data):
        global set_command
        # sometimes the statusbar does not get cleared; do it manually
        self.clear_status(None, None)
        chooser = gtk.FileSelection("Create background menu")
        chooser.set_transient_for(self.window)
        chooser.set_select_multiple(gtk.FALSE)
        if chooser.run() == gtk.RESPONSE_OK:
            file = chooser.get_filename()
            f = open(file, "w")
            f.write("[submenu] (Backgrounds)\n")
            for i in self.images:
                f.write("  [exec] (" + i.description + ") {" + set_command +\
                        " " + i.filename + "}\n")
            f.close()
        chooser.destroy()

    def create_list(self, widget, data):
        # sometimes the statusbar does not get cleared; do it manually
        self.clear_status(None, None)
        chooser = gtk.FileSelection("Create background list")
        chooser.set_transient_for(self.window)
        chooser.set_select_multiple(gtk.FALSE)
        if chooser.run() == gtk.RESPONSE_OK:
            file = chooser.get_filename()
            f = open(file, "w")
            for i in self.images:
                f.write(i.filename + "\n")
            f.close()
        chooser.destroy()

    def random_background(self, widget, data):
        if self.images:
            img = choice(self.images)
            self.set(widget, img)

    def about(self, widget, data):
        global version
        # sometimes the statusbar does not get cleared; do it manually
        self.clear_status(None, None)
        text = "bbbm " + version + "\nWritten by Rob Spoor\n\n" +\
               "CopyRight 2004 Rob Spoor"
        dialog = gtk.MessageDialog(self.window, 0, gtk.MESSAGE_INFO,\
                                   gtk.BUTTONS_OK, text)
        dialog.set_title("About")
        dialog.run()
        dialog.destroy()

    def set_img(self, image, event):
        if event.type == gtk.gdk._2BUTTON_PRESS:
            self.set(None, image)

    def popup(self, image, event):
        # button 3 should be the right button
        if event.type == gtk.gdk.BUTTON_RELEASE and event.button == 3:
            popup = gtk.Menu()
            menu_items = [
                ("_Set", self.set), ("_View", self.view), ("<sep>", None),
                ("_Edit description", self.edit_descr),
                ("_Delete", self.delete)
            ]
            for name, action in menu_items:
                if name == "<sep>":
                    item = gtk.SeparatorMenuItem()
                else:
                    item = gtk.MenuItem(name)
                if action:
                    item.connect("activate", action, image)
                item.show()
                popup.append(item)
            popup.popup(None, None, None, event.button, event.time)

    def set(self, widget, image):
        global set_command
        os.spawnvp(os.P_WAIT, set_command, [set_command, image.filename])

    def view(self, widget, image):
        global view_command
        os.spawnvp(os.P_WAIT, view_command, [view_command, image.filename])

    def edit_descr(self, widget, image):
        # sometimes the statusbar does not get cleared; do it manually
        self.clear_status(None, None)
        dialog = gtk.Dialog("Edit description", self.window, 0,\
                            (gtk.STOCK_OK, gtk.RESPONSE_OK,
                             gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL))
        frame = gtk.Frame("Description")
        frame.show()
        table = gtk.Table(2, 1, gtk.TRUE)
        table.show()
        frame.add(table)
        label = gtk.Label("Description:")
        label.show()
        table.attach(label, 0, 1, 0, 1)
        entry = gtk.Entry()
        entry.set_text(image.description)
        entry.show()
        table.attach(entry, 0, 1, 1, 2)
        dialog.vbox.pack_start(frame, gtk.TRUE, gtk.TRUE, 0)

        if dialog.run() == gtk.RESPONSE_OK:
            image.description = entry.get_text()
        dialog.destroy()

    def delete(self, widget, image):
        global config
        i = self.images.index(image)
        self.images.remove(image)
        self.table.remove(image)
        if i == len(self.images):
            # just remove it, no need to call self.layout
            pass
        else:
            self.layout(i)

if __name__ == "__main__":
    try:
        opts, files = getopt(sys.argv[1:], "hv", ["help", "version"])
    except GetoptError, e:
        sys.stderr.write("bbbm: " + str(e) + "\n")
        sys.stderr.write("Try `bbbm --help` for more information\n")
        sys.exit(1)
    for o in opts:
        if o[0] == "-h" or o[0] == "--help":
            print "Usage: bbbm [OPTIONS] [COLLECTION]"
            print "Opens the Blackbox background manager."
            print
            print "  -h, --help     Output this help and exit"
            print "  -v, --version  Output version information and exit"
            sys.exit(0)
        if o[0] == "-v" or o[0] == "--version":
            print "bbbm", version
            print "Written by Rob Spoor"
            print
            print "CopyRight 2004 Rob Spoor"
            sys.exit(0)
    if not exists(homedir):
        os.mkdir(homedir)
    if not exists(config):
        conf = open(config, "w")
        conf.close()
        set_command, view_command = "bsetbg", "gqview"
        thumb_size, thumb_cols = "128x96", 4
        write_options()
    read_options()

    BBBM(files)
    gtk.main()

